<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Notatnik Głosowy PWA</title>
    
    <!-- Meta tagi dla PWA -->
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Twój osobisty dziennik głosowy. Zamieniaj myśli na tekst.">

    <!-- Hack PWA Single-File: Manifest inlined -->
    <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiVm9pY2VCcmFpbiIsInNob3J0X25hbWUiOiJWb2ljZUJyYWluIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwZjE3MmEiLCJ0aGVtZV9jb2xvciI6IiMwZjE3MmEiLCJpY29ucyI6W3sic3JjIjoiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtZnJlZUA2L3N2Z3Mvc29saWQvbWljcm9waG9uZS5zdmciLCJzaXplcyI6IjUxMng1MTIiLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCJ9XX0=" />

    <!-- Tailwind CSS (Script CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: {
                            800: '#1e293b',
                            900: '#0f172a',
                        },
                        indigo: {
                            500: '#6366f1',
                        }
                    },
                    animation: {
                        'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Dexie.js (IndexedDB Wrapper) -->
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.js"></script>

    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>

    <style>
        /* Ukrycie paska przewijania dla czystszego wyglądu na mobile */
        ::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        body {
            -webkit-tap-highlight-color: transparent;
        }
        /* Auto-resize textarea */
        textarea {
            field-sizing: content;
            min-height: 3rem;
        }
    </style>
</head>
<body class="bg-slate-900 text-white font-sans antialiased min-h-screen pb-24" x-data="voiceJournal()">

    <!-- Sticky Header z Wyszukiwarką i Opcjami -->
    <header class="sticky top-0 z-50 bg-slate-900/95 backdrop-blur-sm p-4 border-b border-slate-800 shadow-md">
        <div class="max-w-md mx-auto">
            <div class="flex justify-between items-center mb-3">
                <h1 class="text-xl font-bold tracking-wide text-indigo-400 flex items-center">
                    <i class="fas fa-microphone-alt mr-2"></i>Voice Brain
                </h1>
                
                <!-- Przycisk Opcji -->
                <div class="relative" x-data="{ open: false }">
                    <button @click="open = !open" class="text-slate-400 hover:text-white transition-colors p-2">
                        <i class="fas fa-cog"></i>
                    </button>
                    <!-- Dropdown Opcji -->
                    <div x-show="open" 
                         @click.outside="open = false"
                         x-transition.origin.top.right
                         class="absolute right-0 top-full mt-2 w-48 bg-slate-800 rounded-lg shadow-xl border border-slate-700 z-50 overflow-hidden">
                        <button @click="exportBackup(); open = false" class="w-full text-left px-4 py-3 text-sm text-slate-300 hover:bg-slate-700 hover:text-white transition-colors flex items-center">
                            <i class="fas fa-file-export mr-2 w-5"></i> Eksportuj kopię
                        </button>
                    </div>
                </div>
            </div>

            <div class="relative">
                <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-400"></i>
                <input 
                    type="text" 
                    x-model="searchQuery" 
                    placeholder="Szukaj w myślach..." 
                    class="w-full bg-slate-800 text-white rounded-full py-2 pl-10 pr-4 focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-slate-500 transition-all shadow-inner border border-slate-700"
                >
            </div>
        </div>
    </header>

    <!-- Główna Lista Notatek -->
    <main class="max-w-md mx-auto p-4 space-y-6">
        
        <!-- Stan ładowania -->
        <template x-if="isLoading">
            <div class="text-center text-slate-500 mt-10">
                <i class="fas fa-spinner fa-spin fa-2x mb-2"></i>
                <p>Ładowanie wspomnień...</p>
            </div>
        </template>

        <!-- Stan pustej listy -->
        <template x-if="!isLoading && filteredNotes.length === 0">
            <div class="text-center text-slate-600 mt-20 flex flex-col items-center">
                <div class="bg-slate-800 p-6 rounded-full mb-4">
                    <i class="fas fa-feather-alt text-4xl text-slate-700"></i>
                </div>
                <p class="text-lg">Brak notatek</p>
                <p class="text-sm opacity-60">Naciśnij mikrofon, aby zacząć.</p>
            </div>
        </template>

        <!-- Grupowana Lista Notatek -->
        <template x-for="group in groupedNotes" :key="group.title">
            <div class="space-y-3">
                <!-- Nagłówek Grupy -->
                <h2 class="text-xs font-bold text-slate-500 uppercase tracking-wider pl-1" x-text="group.title"></h2>

                <!-- Karty Notatek -->
                <template x-for="note in group.notes" :key="note.id">
                    <div class="bg-slate-800 rounded-xl p-5 shadow-lg relative group transition-all hover:bg-slate-750 border border-slate-700/50">
                        
                        <!-- Przyciski akcji (góra) -->
                        <div class="absolute top-3 right-3 flex space-x-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <!-- Edycja -->
                            <button 
                                @click="startEditing(note)" 
                                x-show="editingNoteId !== note.id"
                                class="text-slate-500 hover:text-indigo-400 p-2 transition-colors"
                                title="Edytuj"
                            >
                                <i class="fas fa-pen"></i>
                            </button>
                            <!-- Usuwanie -->
                            <button 
                                @click="deleteNote(note.id)" 
                                x-show="editingNoteId !== note.id"
                                class="text-slate-500 hover:text-red-400 p-2 transition-colors"
                                title="Usuń"
                            >
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        
                        <!-- Data -->
                        <div class="text-xs text-indigo-400 font-medium mb-2 flex items-center">
                            <i class="far fa-clock mr-1"></i>
                            <span x-text="formatTime(note.date)"></span>
                        </div>
                        
                        <!-- Treść: Widok -->
                        <div x-show="editingNoteId !== note.id">
                            <p class="text-slate-200 leading-relaxed whitespace-pre-wrap" x-text="note.text"></p>
                        </div>

                        <!-- Treść: Edycja -->
                        <div x-show="editingNoteId === note.id" class="mt-2">
                            <textarea 
                                x-model="editingText" 
                                class="w-full bg-slate-900/50 text-white rounded-lg p-3 border border-indigo-500/50 focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-y"
                                rows="3"
                                @keydown.escape="cancelEditing()"
                            ></textarea>
                            <div class="flex justify-end space-x-3 mt-3">
                                <button @click="cancelEditing()" class="text-sm text-slate-400 hover:text-white px-3 py-1">Anuluj</button>
                                <button @click="saveEdit(note.id)" class="text-sm bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-1.5 rounded-full shadow-lg flex items-center">
                                    <i class="fas fa-save mr-2"></i> Zapisz
                                </button>
                            </div>
                        </div>

                    </div>
                </template>
            </div>
        </template>
        
        <div class="h-16"></div>
    </main>

    <!-- Podgląd nagrywania (Interim Results) -->
    <div x-show="isRecording" 
         style="display: none;"
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0 translate-y-10"
         x-transition:enter-end="opacity-100 translate-y-0"
         x-transition:leave="transition ease-in duration-200"
         x-transition:leave-start="opacity-100 translate-y-0"
         x-transition:leave-end="opacity-0 translate-y-10"
         class="fixed bottom-24 left-0 right-0 px-4 z-40 pointer-events-none">
        <div class="max-w-md mx-auto bg-slate-800/90 backdrop-blur border border-indigo-500/30 p-4 rounded-2xl shadow-2xl text-center pointer-events-auto">
            <p class="text-indigo-300 text-sm mb-1 font-semibold animate-pulse">Nasłuchiwanie...</p>
            <p class="text-white text-lg italic" x-text="currentTranscript || 'Mów teraz...'"></p>
        </div>
    </div>

    <!-- Floating Action Button (FAB) -->
    <div class="fixed bottom-6 left-0 right-0 flex justify-center z-50 pointer-events-none">
        <button 
            @click="toggleRecording()" 
            class="pointer-events-auto w-16 h-16 rounded-full shadow-2xl flex items-center justify-center text-2xl transition-all duration-300 transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-4 focus:ring-indigo-500/50"
            :class="isRecording ? 'bg-red-500 text-white animate-pulse-fast ring-4 ring-red-500/30' : 'bg-indigo-500 text-white hover:bg-indigo-600'"
            aria-label="Nagrywaj"
        >
            <i class="fas" :class="isRecording ? 'fa-stop' : 'fa-microphone'"></i>
        </button>
    </div>

    <!-- Modal błędu -->
    <div x-show="errorMsg" style="display: none;" 
         class="fixed inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4"
         x-transition.opacity>
        <div class="bg-slate-800 rounded-2xl p-6 max-w-sm w-full text-center border border-red-500/30 shadow-2xl">
            <div class="w-12 h-12 bg-red-500/10 rounded-full flex items-center justify-center mx-auto mb-4">
                <i class="fas fa-exclamation-triangle text-red-500 text-xl"></i>
            </div>
            <h3 class="text-lg font-bold text-white mb-2">Wystąpił błąd</h3>
            <p class="text-slate-300 mb-6 text-sm" x-text="errorMsg"></p>
            <button @click="errorMsg = null" class="bg-slate-700 hover:bg-slate-600 text-white px-6 py-2 rounded-full w-full transition-colors">
                Rozumiem
            </button>
        </div>
    </div>

    <script>
        // --- Konfiguracja Bazy Danych (Dexie.js) ---
        const db = new Dexie('VoiceBrainDB');
        db.version(1).stores({
            notes: '++id, date, text'
        });

        document.addEventListener('alpine:init', () => {
            Alpine.data('voiceJournal', () => ({
                notes: [],
                searchQuery: '',
                isRecording: false,
                manualStop: false, // Flaga: czy użytkownik zatrzymał nagrywanie ręcznie
                currentTranscript: '',
                sessionTranscriptBuffer: '', // Pełny tekst z poprzednich sesji
                currentSessionFinal: '',     // Tekst zatwierdzony w obecnej sesji
                recognition: null,
                isLoading: true,
                errorMsg: null,
                
                // Edycja
                editingNoteId: null,
                editingText: '',

                async init() {
                    console.log('Inicjalizacja Voice Brain...');
                    await this.loadNotes();
                    this.setupSpeechRecognition();
                },

                // --- Zarządzanie Notatkami ---

                async loadNotes() {
                    try {
                        this.notes = (await db.notes.toArray()).sort((a, b) => b.date - a.date);
                    } catch (e) {
                        console.error('Błąd DB:', e);
                        this.errorMsg = 'Nie udało się załadować notatek.';
                    } finally {
                        this.isLoading = false;
                    }
                },

                get filteredNotes() {
                    if (!this.searchQuery) return this.notes;
                    const lowerQuery = this.searchQuery.toLowerCase();
                    return this.notes.filter(note => 
                        note.text.toLowerCase().includes(lowerQuery)
                    );
                },

                // Grupowanie notatek po dacie
                get groupedNotes() {
                    const groups = {};
                    const today = new Date().toDateString();
                    const yesterday = new Date(new Date().setDate(new Date().getDate() - 1)).toDateString();

                    this.filteredNotes.forEach(note => {
                        const noteDate = new Date(note.date).toDateString();
                        let groupTitle = noteDate;
                        
                        if (noteDate === today) groupTitle = 'Dzisiaj';
                        else if (noteDate === yesterday) groupTitle = 'Wczoraj';
                        else {
                             // Formatowanie pełnej daty dla starszych
                             groupTitle = new Date(note.date).toLocaleDateString('pl-PL', { weekday: 'long', day: 'numeric', month: 'long' });
                        }

                        if (!groups[groupTitle]) {
                            groups[groupTitle] = { title: groupTitle, notes: [] };
                        }
                        groups[groupTitle].notes.push(note);
                    });

                    // Konwersja obiektu na tablicę (zachowując kolejność kluczy nie jest gwarantowane, ale sortowanie notatek było chronologiczne, więc iteracja powinna być ok)
                    // Dla pewności sortujemy klucze grup (choć w tym przypadku klucze to stringi, więc trudniej. Lepiej polegać na kolejności pojawiania się)
                    return Object.values(groups); 
                },

                async saveNote(text) {
                    if (!text || text.trim().length === 0) return;
                    try {
                        await db.notes.add({
                            text: text.trim(),
                            date: new Date()
                        });
                        await this.loadNotes();
                        if (navigator.vibrate) navigator.vibrate(50);
                    } catch (e) {
                        console.error('Błąd zapisu:', e);
                        this.errorMsg = 'Nie udało się zapisać notatki.';
                    }
                },

                async deleteNote(id) {
                    if (!confirm('Usunąć notatkę?')) return;
                    try {
                        await db.notes.delete(id);
                        await this.loadNotes();
                    } catch (e) {
                        console.error('Błąd usuwania:', e);
                        this.errorMsg = 'Nie udało się usunąć notatki.';
                    }
                },

                // --- Edycja Inline ---
                startEditing(note) {
                    this.editingNoteId = note.id;
                    this.editingText = note.text;
                },
                
                cancelEditing() {
                    this.editingNoteId = null;
                    this.editingText = '';
                },

                async saveEdit(id) {
                    try {
                        await db.notes.update(id, { text: this.editingText });
                        await this.loadNotes();
                        this.editingNoteId = null;
                    } catch (e) {
                        this.errorMsg = 'Błąd aktualizacji notatki';
                    }
                },

                // --- Export / Backup ---
                async exportBackup() {
                    try {
                        const allData = await db.notes.toArray();
                        const dataStr = JSON.stringify(allData, null, 2);
                        const blob = new Blob([dataStr], { type: "application/json" });
                        const url = URL.createObjectURL(blob);
                        
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `voice-journal-backup-${new Date().toISOString().slice(0,10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        this.errorMsg = 'Nie udało się wyeksportować danych.';
                    }
                },

                // --- Web Speech API (Auto-Restart Loop) ---
                setupSpeechRecognition() {
                    // Sprawdź dostępność API
                    this.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!this.SpeechRecognition) {
                        this.errorMsg = 'Twoja przeglądarka nie obsługuje rozpoznawania mowy.';
                    }
                },

                startRecordingLoop() {
                    if (!this.SpeechRecognition) return;

                    // ZAWSZE twórz nową instancję przy starcie/restarcie, aby uniknąć duplikacji (Android bug)
                    // oraz problemów z "pamięcią" instancji.
                    this.recognition = new this.SpeechRecognition();
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'pl-PL';

                    this.recognition.onstart = () => {
                        this.isRecording = true;
                        this.currentSessionFinal = ''; 
                        console.log('Nagrywanie rozpoczęte (nowa instancja)');
                    };

                    this.recognition.onresult = (event) => {
                        let interim = '';
                        let finalForThisSession = '';

                        for (let i = 0; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {
                                finalForThisSession += event.results[i][0].transcript + ' ';
                            } else {
                                interim += event.results[i][0].transcript;
                            }
                        }
                        
                        this.currentSessionFinal = finalForThisSession;
                        
                        // Łączenie
                        let rawFullText = (this.sessionTranscriptBuffer + ' ' + finalForThisSession + ' ' + interim);
                        
                        // Zaawansowana normalizacja i deduplikacja powtórzeń (dla "test test test")
                        this.currentTranscript = this.cleanText(rawFullText);
                    };

                    this.recognition.onerror = (event) => {
                        console.error('Błąd Speech API:', event.error);
                        if (event.error === 'no-speech') return; 
                        
                        if (event.error === 'network') {
                            // ignoruj, onend obsłuży restart
                        } else {
                             this.isRecording = false;
                             this.manualStop = true;
                        }
                    };

                    this.recognition.onend = () => {
                        console.log('Nagrywanie zakończone (event)');
                        
                        // Zatwierdź wynik tej sesji
                        this.sessionTranscriptBuffer += this.currentSessionFinal;
                        // Oczyść buffer z ewentualnych duplikatów po zatwierdzeniu
                        this.sessionTranscriptBuffer = this.cleanText(this.sessionTranscriptBuffer) + ' ';
                        
                        this.currentSessionFinal = '';

                        // LOGIKA AUTO-RESTARTU
                        if (!this.manualStop && this.isRecording) {
                            console.log('Auto-restart nagrywania...');
                            // Krótkie opóźnienie dla stabilności
                            setTimeout(() => {
                                if(!this.manualStop) this.startRecordingLoop();
                            }, 100);
                        } else {
                            this.isRecording = false;
                            
                            const finalToSave = this.sessionTranscriptBuffer.trim();
                            if (finalToSave) {
                                this.saveNote(finalToSave);
                            }
                            
                            this.currentTranscript = '';
                            this.sessionTranscriptBuffer = '';
                        }
                    };

                    try {
                        this.recognition.start();
                    } catch (e) {
                        console.error('Start error:', e);
                    }
                },

                cleanText(text) {
                    if (!text) return '';
                    // 1. Usuń wielokrotne spacje
                    let clean = text.replace(/\s+/g, ' ').trim();
                    // 2. Usuń proste powtórzenia słów (np. "test test" -> "test")
                    // Regex łapie powtórzone słowo (co najmniej 3 litery) oddzielone spacją
                    // Używamy pętli, aby usunąć wielokrotne powtórzenia (test test test -> test)
                    let prev;
                    do {
                        prev = clean;
                        clean = clean.replace(/(\b\w{3,}\b)( \1\b)+/gi, '$1');
                    } while (clean !== prev);
                    
                    return clean;
                },

                toggleRecording() {
                    if (!this.SpeechRecognition) return;

                    if (this.isRecording) {
                        // STOP
                        this.manualStop = true; 
                        if (this.recognition) this.recognition.stop();
                        this.isRecording = false;
                    } else {
                        // START
                        this.manualStop = false;
                        this.sessionTranscriptBuffer = ''; 
                        this.currentSessionFinal = '';
                        this.currentTranscript = '';
                        this.startRecordingLoop();
                    }
                },

                // --- Pomocnicze ---
                formatTime(dateObj) {
                    if (!dateObj) return '';
                    return new Date(dateObj).toLocaleTimeString('pl-PL', { 
                        hour: '2-digit', minute: '2-digit' 
                    });
                }
            }));
        });
    </script>
</body>
</html>
