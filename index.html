<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voice Brain - Notatki z Przypomnieniami</title>
    
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Tw√≥j osobisty dziennik g≈Çosowy z inteligentnymi przypomnieniami.">

    <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiVm9pY2VCcmFpbiIsInNob3J0X25hbWUiOiJWb2ljZUJyYWluIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwZjE3MmEiLCJ0aGVtZV9jb2xvciI6IiMwZjE3MmEiLCJpY29ucyI6W3sic3JjIjoiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtZnJlZUA2L3N2Z3Mvc29saWQvbWljcm9waG9uZS5zdmciLCJzaXplcyI6IjUxMng1MTIiLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCJ9XX0=" />

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: {
                            800: '#1e293b',
                            900: '#0f172a',
                            750: '#252f40',
                        },
                        indigo: {
                            500: '#6366f1',
                        }
                    },
                    animation: {
                        'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>

    <style>
        ::-webkit-scrollbar { width: 0px; background: transparent; }
        body { -webkit-tap-highlight-color: transparent; }
        textarea { field-sizing: content; min-height: 3rem; }
        .recording-wave {
            display: inline-block;
            width: 6px;
            height: 20px;
            margin: 0 2px;
            background-color: #6366f1;
            border-radius: 3px;
            animation: wave 1s infinite ease-in-out;
        }
        .recording-wave:nth-child(2) { animation-delay: 0.1s; }
        .recording-wave:nth-child(3) { animation-delay: 0.2s; }
        @keyframes wave {
            0%, 100% { height: 10px; opacity: 0.5; }
            50% { height: 25px; opacity: 1; }
        }
        .reminder-badge {
            animation: pulse-glow 2s ease-in-out infinite;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(251, 191, 36, 0.5); }
            50% { box-shadow: 0 0 20px rgba(251, 191, 36, 0.8); }
        }
    </style>
</head>
<body class="bg-slate-900 text-white font-sans antialiased min-h-screen flex flex-col relative" x-data="voiceJournal()">

    <header class="sticky top-0 z-50 bg-slate-900/95 backdrop-blur-sm p-4 border-b border-slate-800 shadow-md">
        <div class="max-w-md mx-auto">
            <div class="flex justify-between items-center mb-3">
                <h1 class="text-xl font-bold tracking-wide text-indigo-400 flex items-center">
                    <i class="fas fa-microphone-alt mr-2"></i>Voice Brain
                    <span class="ml-2 text-xs bg-amber-500/20 text-amber-300 px-2 py-0.5 rounded-full">+Przypomnienia</span>
                </h1>
                
                <div class="flex items-center space-x-2">
                    <!-- Przycisk Przypomnienia -->
                    <button @click="showReminders = !showReminders" class="relative text-slate-400 hover:text-amber-400 transition-colors p-2">
                        <i class="fas fa-bell"></i>
                        <span x-show="activeRemindersCount > 0" class="absolute -top-1 -right-1 bg-amber-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center" x-text="activeRemindersCount"></span>
                    </button>
                    
                    <!-- Przycisk Opcji -->
                    <div class="relative" x-data="{ open: false }">
                        <button @click="open = !open" class="text-slate-400 hover:text-white transition-colors p-2">
                            <i class="fas fa-cog"></i>
                        </button>
                        <div x-show="open" 
                             @click.outside="open = false"
                             x-transition.origin.top.right
                             class="absolute right-0 top-full mt-2 w-48 bg-slate-800 rounded-lg shadow-xl border border-slate-700 z-50 overflow-hidden">
                            <button @click="requestNotificationPermission(); open = false" class="w-full text-left px-4 py-3 text-sm text-slate-300 hover:bg-slate-700 hover:text-white transition-colors flex items-center">
                                <i class="fas fa-bell mr-2 w-5"></i> Powiadomienia
                            </button>
                            <button @click="exportBackup(); open = false" class="w-full text-left px-4 py-3 text-sm text-slate-300 hover:bg-slate-700 hover:text-white transition-colors flex items-center">
                                <i class="fas fa-file-export mr-2 w-5"></i> Eksportuj kopiƒô
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="relative">
                <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-400"></i>
                <input 
                    type="text" 
                    x-model="searchQuery" 
                    placeholder="Szukaj w tytu≈Çach..." 
                    class="w-full bg-slate-800 text-white rounded-full py-2 pl-10 pr-4 focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-slate-500 transition-all shadow-inner border border-slate-700"
                >
            </div>
        </div>
    </header>

    <!-- Panel Przypomnie≈Ñ -->
    <div x-show="showReminders" 
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0 -translate-y-10"
         x-transition:enter-end="opacity-100 translate-y-0"
         class="max-w-md mx-auto w-full px-4 pt-4">
        <div class="bg-gradient-to-br from-amber-500/10 to-orange-500/10 border border-amber-500/30 rounded-xl p-4 backdrop-blur">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-lg font-bold text-amber-300 flex items-center">
                    <i class="fas fa-bell mr-2"></i>NadchodzƒÖce przypomnienia
                </h2>
                <button @click="showReminders = false" class="text-amber-400 hover:text-amber-300">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <template x-if="upcomingReminders.length === 0">
                <p class="text-slate-400 text-sm text-center py-4">Brak aktywnych przypomnie≈Ñ</p>
            </template>
            
            <div class="space-y-2">
                <template x-for="reminder in upcomingReminders" :key="reminder.id">
                    <div class="bg-slate-800/50 rounded-lg p-3 flex justify-between items-start">
                        <div class="flex-1">
                            <p class="text-white text-sm font-medium mb-1" x-text="reminder.title"></p>
                            <p class="text-amber-400 text-xs flex items-center">
                                <i class="far fa-clock mr-1"></i>
                                <span x-text="formatReminderTime(reminder.reminderDate)"></span>
                            </p>
                        </div>
                        <button @click="deleteReminder(reminder.id)" class="text-slate-500 hover:text-red-400 ml-2">
                            <i class="fas fa-trash-alt text-sm"></i>
                        </button>
                    </div>
                </template>
            </div>
        </div>
    </div>

    <main class="max-w-md mx-auto p-4 space-y-6 flex-grow pb-36 w-full">
        
        <template x-if="isLoading">
            <div class="text-center text-slate-500 mt-10">
                <i class="fas fa-spinner fa-spin fa-2x mb-2"></i>
                <p>≈Åadowanie wspomnie≈Ñ...</p>
            </div>
        </template>

        <template x-if="!isLoading && filteredNotes.length === 0">
            <div class="text-center text-slate-600 mt-20 flex flex-col items-center">
                <div class="bg-slate-800 p-6 rounded-full mb-4">
                    <i class="fas fa-feather-alt text-4xl text-slate-700"></i>
                </div>
                <p class="text-lg">Brak notatek</p>
                <p class="text-sm opacity-60">Naci≈õnij mikrofon, aby zaczƒÖƒá.</p>
                <p class="text-xs text-amber-400 mt-2">üí° Powiedz: "Przypomnij mi jutro o 10"</p>
            </div>
        </template>

        <template x-for="group in groupedNotes" :key="group.title">
            <div class="space-y-3">
                <h2 class="text-xs font-bold text-slate-500 uppercase tracking-wider pl-1" x-text="group.title"></h2>

                <template x-for="note in group.notes" :key="note.id">
                    <div class="bg-slate-800 rounded-xl p-5 shadow-lg relative group transition-all hover:bg-slate-750 border border-slate-700/50"
                         :class="note.hasReminder && !note.reminderCompleted ? 'ring-2 ring-amber-500/30' : ''">
                        
                        <!-- Reminder Badge -->
                        <div x-show="note.hasReminder && !note.reminderCompleted" class="absolute -top-2 -right-2 bg-amber-500 text-white text-xs px-2 py-1 rounded-full flex items-center space-x-1 reminder-badge">
                            <i class="fas fa-bell text-xs"></i>
                            <span x-text="formatReminderBadge(note.reminderDate)"></span>
                        </div>

                        <div class="absolute top-3 right-3 flex space-x-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <button @click="startEditing(note)" x-show="editingNoteId !== note.id" class="text-slate-500 hover:text-indigo-400 p-2"><i class="fas fa-pen"></i></button>
                            <button @click="deleteNote(note.id)" x-show="editingNoteId !== note.id" class="text-slate-500 hover:text-red-400 p-2"><i class="fas fa-times"></i></button>
                        </div>
                        
                        <div class="mb-2">
                            <h3 class="text-lg font-bold text-white leading-tight" x-text="note.title || 'Bez tytu≈Çu'"></h3>
                        </div>

                        <div class="text-xs text-indigo-400 font-medium mb-3 flex items-center">
                            <i class="far fa-clock mr-1"></i>
                            <span x-text="formatTime(note.date)"></span>
                        </div>
                        
                        <div x-show="editingNoteId !== note.id">
                            <p class="text-slate-300 text-sm leading-relaxed whitespace-pre-wrap opacity-80" x-text="note.text"></p>
                        </div>

                        <div x-show="editingNoteId === note.id" class="mt-2">
                            <textarea x-model="editingText" class="w-full bg-slate-900/50 text-white rounded-lg p-3 border border-indigo-500/50 focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-y text-sm" rows="3"></textarea>
                            <div class="flex justify-end space-x-3 mt-3">
                                <button @click="cancelEditing()" class="text-sm text-slate-400 hover:text-white px-3 py-1">Anuluj</button>
                                <button @click="saveEdit(note.id)" class="text-sm bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-1.5 rounded-full shadow-lg flex items-center">
                                    <i class="fas fa-save mr-2"></i> Zapisz
                                </button>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </template>
    </main>

    <footer class="text-center py-6 text-slate-600 text-xs z-10 bg-slate-900 w-full">
        <span>Wykonanie Tomasz Wawrzak 2026 z asystƒÖ AI Claude</span>
    </footer>

    <div x-show="isRecording" style="display: none;"
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0 translate-y-10"
         x-transition:enter-end="opacity-100 translate-y-0"
         class="fixed bottom-40 left-0 right-0 px-4 z-40 pointer-events-none">
        <div class="max-w-md mx-auto bg-slate-800/90 backdrop-blur border border-indigo-500/30 p-4 rounded-2xl shadow-2xl text-center pointer-events-auto">
            <p class="text-indigo-300 text-sm mb-1 font-semibold animate-pulse flex justify-center items-center">
                <span class="recording-wave"></span>
                <span class="recording-wave"></span>
                <span class="recording-wave"></span>
                &nbsp;Nas≈Çuchiwanie...
            </p>
            <p class="text-white text-lg italic" x-text="currentTranscript || 'M√≥w teraz...'"></p>
            <p x-show="detectedReminder" class="text-amber-400 text-xs mt-2 animate-pulse">
                <i class="fas fa-bell mr-1"></i>Wykryto przypomnienie!
            </p>
        </div>
    </div>

    <div class="fixed bottom-20 left-0 right-0 flex justify-center z-50 pointer-events-none">
        <button 
            @click="toggleRecording()" 
            class="pointer-events-auto w-16 h-16 rounded-full shadow-2xl flex items-center justify-center text-2xl transition-all duration-300 transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-4 focus:ring-indigo-500/50"
            :class="isRecording ? 'bg-red-500 text-white animate-pulse-fast ring-4 ring-red-500/30' : 'bg-indigo-500 text-white hover:bg-indigo-600'"
            aria-label="Nagrywaj">
            <i class="fas" :class="isRecording ? 'fa-stop' : 'fa-microphone'"></i>
        </button>
    </div>

    <div x-show="errorMsg" style="display: none;" class="fixed inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4" x-transition.opacity>
        <div class="bg-slate-800 rounded-2xl p-6 max-w-sm w-full text-center border border-red-500/30 shadow-2xl">
            <div class="w-12 h-12 bg-red-500/10 rounded-full flex items-center justify-center mx-auto mb-4"><i class="fas fa-exclamation-triangle text-red-500 text-xl"></i></div>
            <h3 class="text-lg font-bold text-white mb-2">WystƒÖpi≈Ç b≈ÇƒÖd</h3>
            <p class="text-slate-300 mb-6 text-sm" x-text="errorMsg"></p>
            <button @click="errorMsg = null" class="bg-slate-700 hover:bg-slate-600 text-white px-6 py-2 rounded-full w-full transition-colors">Rozumiem</button>
        </div>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playBeep(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'start') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); 
                oscillator.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1); 
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.1); 
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            }
        }

        const db = new Dexie('VoiceBrainDB');
        db.version(1).stores({ notes: '++id, date, text' });
        db.version(2).stores({ notes: '++id, date, text, title' });
        db.version(3).stores({ notes: '++id, date, text, title, hasReminder, reminderDate, reminderCompleted' }).upgrade(tx => {
            return tx.table('notes').toCollection().modify(note => {
                note.hasReminder = note.hasReminder || false;
                note.reminderDate = note.reminderDate || null;
                note.reminderCompleted = note.reminderCompleted || false;
            });
        });

        document.addEventListener('alpine:init', () => {
            Alpine.data('voiceJournal', () => ({
                notes: [],
                searchQuery: '',
                isRecording: false,
                manualStop: false, 
                currentTranscript: '',
                sessionTranscriptBuffer: '',
                currentSessionFinal: '',
                recognition: null,
                isLoading: true,
                errorMsg: null,
                detectedReminder: false,
                showReminders: false,
                
                editingNoteId: null,
                editingText: '',
                
                wakeLock: null,
                reminderCheckInterval: null,

                async init() {
                    console.log('üöÄ Inicjalizacja Voice Brain v3 (z przypomnieniami)...');
                    
                    try {
                        // Testowe otwarcie bazy danych
                        await db.open();
                        console.log('‚úÖ Baza danych otwarta pomy≈õlnie');
                        console.log('üìä Wersja bazy:', db.verno);
                    } catch (e) {
                        console.error('‚ùå B≈ÇƒÖd otwierania bazy danych:', e);
                        this.errorMsg = `B≈ÇƒÖd bazy danych: ${e.message}`;
                    }
                    
                    await this.loadNotes();
                    this.setupSpeechRecognition();
                    this.startReminderCheck();
                    await this.requestNotificationPermission();
                },

                async loadNotes() {
                    try {
                        this.notes = (await db.notes.toArray()).sort((a, b) => b.date - a.date);
                    } catch (e) {
                        console.error('B≈ÇƒÖd DB:', e);
                        this.errorMsg = 'Nie uda≈Ço siƒô za≈Çadowaƒá notatek.';
                    } finally {
                        this.isLoading = false;
                    }
                },

                get filteredNotes() {
                    if (!this.searchQuery) return this.notes;
                    const lowerQuery = this.searchQuery.toLowerCase();
                    return this.notes.filter(note => 
                        (note.title && note.title.toLowerCase().includes(lowerQuery)) ||
                        (note.text && note.text.toLowerCase().includes(lowerQuery))
                    );
                },

                get groupedNotes() {
                    const groups = {};
                    const today = new Date().toDateString();
                    const yesterday = new Date(new Date().setDate(new Date().getDate() - 1)).toDateString();

                    this.filteredNotes.forEach(note => {
                        const noteDate = new Date(note.date).toDateString();
                        let groupTitle = noteDate;
                        if (noteDate === today) groupTitle = 'Dzisiaj';
                        else if (noteDate === yesterday) groupTitle = 'Wczoraj';
                        else groupTitle = new Date(note.date).toLocaleDateString('pl-PL', { weekday: 'long', day: 'numeric', month: 'long' });

                        if (!groups[groupTitle]) {
                            groups[groupTitle] = { title: groupTitle, notes: [] };
                        }
                        groups[groupTitle].notes.push(note);
                    });
                    return Object.values(groups); 
                },

                get upcomingReminders() {
                    const now = new Date();
                    return this.notes
                        .filter(note => note.hasReminder && !note.reminderCompleted && new Date(note.reminderDate) > now)
                        .sort((a, b) => new Date(a.reminderDate) - new Date(b.reminderDate))
                        .slice(0, 10);
                },

                get activeRemindersCount() {
                    return this.upcomingReminders.length;
                },

                parseReminderFromText(text) {
                    console.log('üîç Parsowanie tekstu na przypomnienie:', text);
                    const lowerText = text.toLowerCase();
                    
                    const patterns = [
                        { regex: /przypomnij\s+mi\s+(jutro|dzisiaj|dzi≈õ)\s+(o\s+)?(\d{1,2})(:\d{2})?/i, type: 'specific' },
                        { regex: /przypomnij\s+(jutro|dzisiaj|dzi≈õ)\s+(o\s+)?(\d{1,2})(:\d{2})?/i, type: 'specific' },
                        { regex: /dodaj\s+do\s+kalendarza\s+(jutro|dzisiaj|dzi≈õ)\s+(o\s+)?(\d{1,2})(:\d{2})?/i, type: 'calendar' },
                        { regex: /za\s+(\d+)\s+(godzin|godzinƒô|godziny|minut|minutƒô|minuty|dni|dzie≈Ñ)/i, type: 'relative' },
                        { regex: /(jutro|dzisiaj|dzi≈õ)\s+rano/i, type: 'morning' },
                        { regex: /(jutro|dzisiaj|dzi≈õ)\s+wieczorem/i, type: 'evening' },
                    ];

                    for (const pattern of patterns) {
                        const match = lowerText.match(pattern.regex);
                        if (match) {
                            console.log('‚úÖ Znaleziono wzorzec:', pattern.type, 'Match:', match);
                            const reminderDate = this.calculateReminderDate(match, pattern.type);
                            console.log('üìÖ Wyliczona data przypomnienia:', reminderDate);
                            
                            if (reminderDate) {
                                const cleanedText = text.replace(match[0], '').trim();
                                return { 
                                    hasReminder: true, 
                                    reminderDate: reminderDate,
                                    cleanedText: cleanedText || text
                                };
                            }
                        }
                    }
                    
                    console.log('‚ùå Nie znaleziono wzorca przypomnienia');
                    return { hasReminder: false, cleanedText: text };
                },

                calculateReminderDate(match, type) {
                    const now = new Date();
                    let reminderDate = new Date();

                    if (type === 'specific') {
                        const day = match[1];
                        const hour = parseInt(match[3]);
                        const minutes = match[4] ? parseInt(match[4].substring(1)) : 0;
                        
                        if (day === 'jutro') {
                            reminderDate.setDate(reminderDate.getDate() + 1);
                        }
                        reminderDate.setHours(hour, minutes, 0, 0);
                        
                    } else if (type === 'calendar') {
                        const day = match[1];
                        const hour = parseInt(match[3]);
                        const minutes = match[4] ? parseInt(match[4].substring(1)) : 0;
                        
                        if (day === 'jutro') {
                            reminderDate.setDate(reminderDate.getDate() + 1);
                        }
                        reminderDate.setHours(hour, minutes, 0, 0);
                        
                    } else if (type === 'relative') {
                        const value = parseInt(match[1]);
                        const unit = match[2];
                        
                        if (unit.includes('godzin')) {
                            reminderDate.setHours(reminderDate.getHours() + value);
                        } else if (unit.includes('minut')) {
                            reminderDate.setMinutes(reminderDate.getMinutes() + value);
                        } else if (unit.includes('dni') || unit.includes('dzie≈Ñ')) {
                            reminderDate.setDate(reminderDate.getDate() + value);
                        }
                        
                    } else if (type === 'morning') {
                        const day = match[1];
                        if (day === 'jutro') {
                            reminderDate.setDate(reminderDate.getDate() + 1);
                        }
                        reminderDate.setHours(9, 0, 0, 0);
                        
                    } else if (type === 'evening') {
                        const day = match[1];
                        if (day === 'jutro') {
                            reminderDate.setDate(reminderDate.getDate() + 1);
                        }
                        reminderDate.setHours(18, 0, 0, 0);
                    }

                    return reminderDate > now ? reminderDate : null;
                },

                generateAutoTitle(text) {
                    if (!text || text.trim().length === 0) return 'Nowa notatka';
                    const cleanText = text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"");
                    const words = cleanText.trim().split(/\s+/);
                    const titleWords = words.slice(0, 4);
                    let title = titleWords.join(' ');
                    title = title.charAt(0).toUpperCase() + title.slice(1);
                    if (words.length > 4) title += '...';
                    return title;
                },

                async saveNote(text) {
                    if (!text || text.trim().length === 0) return;
                    try {
                        console.log('üìù Zapisujƒô notatkƒô:', text);
                        const reminderInfo = this.parseReminderFromText(text);
                        console.log('üîî Wynik parsowania przypomnienia:', reminderInfo);
                        
                        const finalText = reminderInfo.cleanedText;
                        const title = this.generateAutoTitle(finalText);
                        
                        const noteData = {
                            text: finalText.trim(),
                            title: title,
                            date: new Date(),
                            hasReminder: reminderInfo.hasReminder,
                            reminderDate: reminderInfo.reminderDate || null,
                            reminderCompleted: false
                        };
                        
                        console.log('üíæ Dane do zapisania:', noteData);
                        
                        const savedId = await db.notes.add(noteData);
                        console.log('‚úÖ Notatka zapisana z ID:', savedId);
                        
                        await this.loadNotes();
                        
                        if (reminderInfo.hasReminder) {
                            console.log('üéâ Pokazujƒô powiadomienie o przypomnieniu');
                            this.showNotification('Przypomnienie ustawione!', 
                                `Przypomnƒô Ci: ${this.formatReminderTime(reminderInfo.reminderDate)}`);
                        }
                        
                        if (navigator.vibrate) navigator.vibrate(50);
                    } catch (e) {
                        console.error('‚ùå B≈ÇƒÖd zapisu - szczeg√≥≈Çy:', e);
                        console.error('‚ùå Stack trace:', e.stack);
                        this.errorMsg = `Nie uda≈Ço siƒô zapisaƒá notatki: ${e.message}`;
                    }
                },

                async deleteNote(id) {
                    if (!confirm('UsunƒÖƒá notatkƒô?')) return;
                    try {
                        await db.notes.delete(id);
                        await this.loadNotes();
                    } catch (e) {
                        console.error('B≈ÇƒÖd usuwania:', e);
                        this.errorMsg = 'Nie uda≈Ço siƒô usunƒÖƒá notatki.';
                    }
                },

                async deleteReminder(id) {
                    try {
                        await db.notes.update(id, { hasReminder: false, reminderCompleted: true });
                        await this.loadNotes();
                    } catch (e) {
                        console.error('B≈ÇƒÖd usuwania przypomnienia:', e);
                    }
                },

                startEditing(note) {
                    this.editingNoteId = note.id;
                    this.editingText = note.text;
                },
                
                cancelEditing() {
                    this.editingNoteId = null;
                    this.editingText = '';
                },

                async saveEdit(id) {
                    try {
                        const title = this.generateAutoTitle(this.editingText);
                        await db.notes.update(id, { text: this.editingText, title: title });
                        await this.loadNotes();
                        this.editingNoteId = null;
                    } catch (e) {
                        this.errorMsg = 'B≈ÇƒÖd aktualizacji notatki';
                    }
                },

                async exportBackup() {
                    try {
                        const allData = await db.notes.toArray();
                        const dataStr = JSON.stringify(allData, null, 2);
                        const blob = new Blob([dataStr], { type: "application/json" });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `voice-journal-backup-${new Date().toISOString().slice(0,10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        this.errorMsg = 'Nie uda≈Ço siƒô wyeksportowaƒá danych.';
                    }
                },

                async requestNotificationPermission() {
                    if (!("Notification" in window)) {
                        console.log("PrzeglƒÖdarka nie wspiera powiadomie≈Ñ");
                        return;
                    }

                    if (Notification.permission === "granted") {
                        console.log("Powiadomienia ju≈º w≈ÇƒÖczone");
                        return;
                    }

                    if (Notification.permission !== "denied") {
                        const permission = await Notification.requestPermission();
                        if (permission === "granted") {
                            this.showNotification("Powiadomienia w≈ÇƒÖczone!", "Bƒôdƒô Ciƒô informowaƒá o przypomnieniach");
                        }
                    }
                },

                showNotification(title, body) {
                    if (Notification.permission === "granted") {
                        new Notification(title, {
                            body: body,
                            icon: 'https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/svgs/solid/bell.svg',
                            badge: 'https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/svgs/solid/microphone.svg',
                            vibrate: [200, 100, 200]
                        });
                    }
                },

                startReminderCheck() {
                    this.reminderCheckInterval = setInterval(async () => {
                        const now = new Date();
                        const reminders = this.notes.filter(note => 
                            note.hasReminder && 
                            !note.reminderCompleted && 
                            new Date(note.reminderDate) <= now
                        );

                        for (const reminder of reminders) {
                            this.showNotification('‚è∞ Przypomnienie!', reminder.title);
                            await db.notes.update(reminder.id, { reminderCompleted: true });
                            if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 200]);
                        }

                        if (reminders.length > 0) {
                            await this.loadNotes();
                        }
                    }, 30000); // Sprawdzaj co 30 sekund
                },

                async requestWakeLock() {
                    if ('wakeLock' in navigator) {
                        try {
                            this.wakeLock = await navigator.wakeLock.request('screen');
                            console.log('Wake Lock aktywny');
                            this.wakeLock.addEventListener('release', () => {
                                console.log('Wake Lock zwolniony');
                                this.wakeLock = null;
                            });
                        } catch (err) {
                            console.error(`B≈ÇƒÖd Wake Lock: ${err.name}, ${err.message}`);
                        }
                    }
                },

                releaseWakeLock() {
                    if (this.wakeLock !== null) {
                        this.wakeLock.release()
                            .then(() => { this.wakeLock = null; });
                    }
                },

                setupSpeechRecognition() {
                    this.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!this.SpeechRecognition) {
                        this.errorMsg = 'Twoja przeglƒÖdarka nie obs≈Çuguje rozpoznawania mowy.';
                    }
                },

                startRecordingLoop() {
                    if (!this.SpeechRecognition) return;

                    this.recognition = new this.SpeechRecognition();
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'pl-PL';

                    this.recognition.onstart = () => {
                        this.isRecording = true;
                        this.currentSessionFinal = ''; 
                        this.detectedReminder = false;
                        console.log('Nagrywanie rozpoczƒôte');
                        playBeep('start');
                    };

                    this.recognition.onresult = (event) => {
                        const results = event.results;
                        const lastResult = results[results.length - 1];
                        const transcript = lastResult[0].transcript;

                        if (lastResult.isFinal) {
                            this.currentSessionFinal = transcript;
                            this.currentTranscript = transcript;
                            
                            const hasReminder = this.parseReminderFromText(transcript).hasReminder;
                            if (hasReminder) {
                                this.detectedReminder = true;
                            }
                        } else {
                            this.currentTranscript = transcript;
                        }
                    };

                    this.recognition.onerror = (event) => {
                        console.error('B≈ÇƒÖd Speech API:', event.error);
                        if (event.error === 'no-speech') return; 
                        if (event.error === 'network') {
                        } else {
                             this.isRecording = false;
                             this.manualStop = true;
                        }
                    };

                    this.recognition.onend = () => {
                        console.log('Nagrywanie zako≈Ñczone (event)');
                        
                        const newFinal = this.currentSessionFinal.trim();
                        const bufferEnd = this.sessionTranscriptBuffer.trim().slice(-newFinal.length);
                        
                        if (newFinal && newFinal !== bufferEnd) {
                            const cleanedNew = this.cleanText(newFinal);
                            if (cleanedNew) {
                                this.sessionTranscriptBuffer += (this.sessionTranscriptBuffer ? ' ' : '') + cleanedNew + ' ';
                            }
                        }
                        
                        this.currentSessionFinal = '';
                        this.currentTranscript = '';

                        if (!this.manualStop && this.isRecording) {
                            console.log('Auto-restart nagrywania...');
                            setTimeout(() => {
                                if(!this.manualStop) this.startRecordingLoop();
                            }, 100);
                        } else {
                            this.isRecording = false;
                            this.detectedReminder = false;
                            playBeep('stop');
                            this.releaseWakeLock();
                            
                            const finalToSave = this.sessionTranscriptBuffer.trim();
                            if (finalToSave) {
                                this.saveNote(finalToSave);
                            }
                            this.sessionTranscriptBuffer = '';
                        }
                    };

                    try {
                        this.recognition.start();
                    } catch (e) {
                        console.error('Start error:', e);
                    }
                },

                cleanText(text) {
                    if (!text) return '';
                    let clean = text.replace(/\s+/g, ' ').trim();
                    clean = clean.replace(/(\b\w{3,}\b)( \1\b)+/gi, '$1');
                    return clean;
                },

                toggleRecording() {
                    if (!this.SpeechRecognition) return;

                    if (this.isRecording) {
                        this.manualStop = true; 
                        if (this.recognition) this.recognition.stop();
                        this.isRecording = false;
                    } else {
                        this.manualStop = false;
                        this.sessionTranscriptBuffer = ''; 
                        this.currentSessionFinal = '';
                        this.currentTranscript = '';
                        this.detectedReminder = false;
                        this.requestWakeLock();
                        this.startRecordingLoop();
                    }
                },

                formatTime(dateObj) {
                    if (!dateObj) return '';
                    return new Date(dateObj).toLocaleTimeString('pl-PL', { 
                        hour: '2-digit', minute: '2-digit' 
                    });
                },

                formatReminderTime(dateObj) {
                    if (!dateObj) return '';
                    const date = new Date(dateObj);
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const tomorrow = new Date(today);
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    const reminderDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                    let dayStr = '';
                    if (reminderDay.getTime() === today.getTime()) {
                        dayStr = 'Dzisiaj';
                    } else if (reminderDay.getTime() === tomorrow.getTime()) {
                        dayStr = 'Jutro';
                    } else {
                        dayStr = date.toLocaleDateString('pl-PL', { day: 'numeric', month: 'short' });
                    }

                    const timeStr = date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' });
                    return `${dayStr} o ${timeStr}`;
                },

                formatReminderBadge(dateObj) {
                    if (!dateObj) return '';
                    const date = new Date(dateObj);
                    const now = new Date();
                    const diffMs = date - now;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMs / 3600000);
                    const diffDays = Math.floor(diffMs / 86400000);

                    if (diffMins < 60) {
                        return `${diffMins}m`;
                    } else if (diffHours < 24) {
                        return `${diffHours}h`;
                    } else {
                        return `${diffDays}d`;
                    }
                }
            }));
        });
    </script>
</body>
</html>