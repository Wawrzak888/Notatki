<script>
        // --- Konfiguracja Bazy Danych (Dexie.js) ---
        const db = new Dexie('VoiceBrainDB');
        db.version(1).stores({
            notes: '++id, date, text'
        });

        document.addEventListener('alpine:init', () => {
            Alpine.data('voiceJournal', () => ({
                notes: [],
                searchQuery: '',
                isRecording: false,
                manualStop: false, 
                
                // --- ZMIENNE DO TRANSKRYPCJI (Fixed) ---
                currentTranscript: '',      
                historyTranscript: '',      
                sessionFinalTranscript: '', 
                
                recognition: null,
                isLoading: true,
                errorMsg: null,
                
                // Edycja
                editingNoteId: null,
                editingText: '',

                async init() {
                    console.log('Inicjalizacja Voice Brain (Fix v3)...');
                    await this.loadNotes();
                    this.setupSpeechRecognition();
                },

                // --- Zarządzanie Notatkami ---

                async loadNotes() {
                    try {
                        this.notes = (await db.notes.toArray()).sort((a, b) => b.date - a.date);
                    } catch (e) {
                        console.error('Błąd DB:', e);
                        this.errorMsg = 'Nie udało się załadować notatek.';
                    } finally {
                        this.isLoading = false;
                    }
                },

                get filteredNotes() {
                    if (!this.searchQuery) return this.notes;
                    const lowerQuery = this.searchQuery.toLowerCase();
                    return this.notes.filter(note => 
                        note.text.toLowerCase().includes(lowerQuery)
                    );
                },

                get groupedNotes() {
                    const groups = {};
                    const today = new Date().toDateString();
                    const yesterday = new Date(new Date().setDate(new Date().getDate() - 1)).toDateString();

                    this.filteredNotes.forEach(note => {
                        const noteDate = new Date(note.date).toDateString();
                        let groupTitle = noteDate;
                        
                        if (noteDate === today) groupTitle = 'Dzisiaj';
                        else if (noteDate === yesterday) groupTitle = 'Wczoraj';
                        else {
                             groupTitle = new Date(note.date).toLocaleDateString('pl-PL', { weekday: 'long', day: 'numeric', month: 'long' });
                        }

                        if (!groups[groupTitle]) {
                            groups[groupTitle] = { title: groupTitle, notes: [] };
                        }
                        groups[groupTitle].notes.push(note);
                    });
                    return Object.values(groups); 
                },

                async saveNote(text) {
                    if (!text || text.trim().length === 0) return;
                    try {
                        await db.notes.add({
                            text: text.trim(),
                            date: new Date()
                        });
                        await this.loadNotes();
                        if (navigator.vibrate) navigator.vibrate(50);
                    } catch (e) {
                        console.error('Błąd zapisu:', e);
                        this.errorMsg = 'Nie udało się zapisać notatki.';
                    }
                },

                async deleteNote(id) {
                    if (!confirm('Usunąć notatkę?')) return;
                    try {
                        await db.notes.delete(id);
                        await this.loadNotes();
                    } catch (e) {
                        console.error('Błąd usuwania:', e);
                        this.errorMsg = 'Nie udało się usunąć notatki.';
                    }
                },

                // --- Edycja Inline ---
                startEditing(note) {
                    this.editingNoteId = note.id;
                    this.editingText = note.text;
                },
                
                cancelEditing() {
                    this.editingNoteId = null;
                    this.editingText = '';
                },

                async saveEdit(id) {
                    try {
                        await db.notes.update(id, { text: this.editingText });
                        await this.loadNotes();
                        this.editingNoteId = null;
                    } catch (e) {
                        this.errorMsg = 'Błąd aktualizacji notatki';
                    }
                },

                // --- Export / Backup ---
                async exportBackup() {
                    try {
                        const allData = await db.notes.toArray();
                        const dataStr = JSON.stringify(allData, null, 2);
                        const blob = new Blob([dataStr], { type: "application/json" });
                        const url = URL.createObjectURL(blob);
                        
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `voice-journal-backup-${new Date().toISOString().slice(0,10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        this.errorMsg = 'Nie udało się wyeksportować danych.';
                    }
                },

                // --- Web Speech API (Fixed Loop) ---
                setupSpeechRecognition() {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!SpeechRecognition) return;

                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'pl-PL';

                    this.recognition.onstart = () => {
                        this.isRecording = true;
                        console.log('Nagrywanie rozpoczęte');
                    };

                    this.recognition.onresult = (event) => {
                        let interim = '';
                        let finalForThisSession = '';

                        for (let i = 0; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {
                                finalForThisSession += event.results[i][0].transcript;
                            } else {
                                interim += event.results[i][0].transcript;
                            }
                        }

                        this.sessionFinalTranscript = finalForThisSession;
                        
                        this.currentTranscript = 
                            (this.historyTranscript + ' ' + this.sessionFinalTranscript + ' ' + interim)
                            .replace(/\s+/g, ' ')
                            .trim();
                    };

                    this.recognition.onerror = (event) => {
                        console.error('Błąd Speech API:', event.error);
                        if (event.error === 'no-speech') return; 
                        
                        if (event.error === 'network') {
                            // Ignoruj network error przy restarcie
                        } else {
                             this.isRecording = false;
                             this.manualStop = true;
                        }
                    };

                    this.recognition.onend = () => {
                        console.log('Nagrywanie zakończone');
                        
                        if (this.sessionFinalTranscript) {
                            this.historyTranscript += ' ' + this.sessionFinalTranscript;
                            this.sessionFinalTranscript = ''; 
                        }

                        if (!this.manualStop && this.isRecording) {
                            try {
                                this.recognition.start();
                            } catch (e) {
                                setTimeout(() => {
                                    if(!this.manualStop) this.recognition.start();
                                }, 200);
                            }
                        } else {
                            this.isRecording = false;
                            
                            const finalNote = this.historyTranscript.trim();
                            if (finalNote) {
                                this.saveNote(finalNote);
                            }
                            
                            this.currentTranscript = '';
                            this.historyTranscript = '';
                            this.sessionFinalTranscript = '';
                        }
                    };
                },

                toggleRecording() {
                    if (!this.recognition) return;

                    if (this.isRecording) {
                        this.manualStop = true; 
                        this.recognition.stop();
                    } else {
                        this.manualStop = false;
                        this.historyTranscript = '';
                        this.sessionFinalTranscript = '';
                        this.currentTranscript = '';
                        try {
                            this.recognition.start();
                        } catch (e) {
                            console.error('Start error:', e);
                        }
                    }
                },

                // --- BRAKUJĄCA FUNKCJA (PRZYWRÓCONA) ---
                formatTime(dateObj) {
                    if (!dateObj) return '';
                    return new Date(dateObj).toLocaleTimeString('pl-PL', { 
                        hour: '2-digit', minute: '2-digit' 
                    });
                }
            }));
        });
    </script>
