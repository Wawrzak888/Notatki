<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Notatnik Głosowy PWA</title>
    
    <!-- Meta tagi dla PWA -->
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Twój osobisty dziennik głosowy. Zamieniaj myśli na tekst.">

    <!-- Hack PWA Single-File: Manifest inlined -->
    <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiVm9pY2VCcmFpbiIsInNob3J0X25hbWUiOiJWb2ljZUJyYWluIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwZjE3MmEiLCJ0aGVtZV9jb2xvciI6IiMwZjE3MmEiLCJpY29ucyI6W3sic3JjIjoiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtZnJlZUA2L3N2Z3Mvc29saWQvbWljcm9waG9uZS5zdmciLCJzaXplcyI6IjUxMng1MTIiLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCJ9XX0=" />

    <!-- Tailwind CSS (Script CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: {
                            800: '#1e293b',
                            900: '#0f172a',
                            750: '#252f40',
                        },
                        indigo: {
                            500: '#6366f1',
                        }
                    },
                    animation: {
                        'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Dexie.js (IndexedDB Wrapper) -->
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.js"></script>

    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>

    <style>
        ::-webkit-scrollbar { width: 0px; background: transparent; }
        body { -webkit-tap-highlight-color: transparent; }
        textarea { field-sizing: content; min-height: 3rem; }
        /* Animacja pojawiania się dźwięków (opcjonalna wizualizacja) */
        .recording-wave {
            display: inline-block;
            width: 6px;
            height: 20px;
            margin: 0 2px;
            background-color: #6366f1;
            border-radius: 3px;
            animation: wave 1s infinite ease-in-out;
        }
        .recording-wave:nth-child(2) { animation-delay: 0.1s; }
        .recording-wave:nth-child(3) { animation-delay: 0.2s; }
        @keyframes wave {
            0%, 100% { height: 10px; opacity: 0.5; }
            50% { height: 25px; opacity: 1; }
        }
    </style>
</head>
<body class="bg-slate-900 text-white font-sans antialiased min-h-screen pb-24" x-data="voiceJournal()">

    <!-- Sticky Header -->
    <header class="sticky top-0 z-50 bg-slate-900/95 backdrop-blur-sm p-4 border-b border-slate-800 shadow-md">
        <div class="max-w-md mx-auto">
            <div class="flex justify-between items-center mb-3">
                <h1 class="text-xl font-bold tracking-wide text-indigo-400 flex items-center">
                    <i class="fas fa-microphone-alt mr-2"></i>Voice Brain
                </h1>
                
                <!-- Przycisk Opcji -->
                <div class="relative" x-data="{ open: false }">
                    <button @click="open = !open" class="text-slate-400 hover:text-white transition-colors p-2">
                        <i class="fas fa-cog"></i>
                    </button>
                    <div x-show="open" 
                         @click.outside="open = false"
                         x-transition.origin.top.right
                         class="absolute right-0 top-full mt-2 w-48 bg-slate-800 rounded-lg shadow-xl border border-slate-700 z-50 overflow-hidden">
                        <button @click="exportBackup(); open = false" class="w-full text-left px-4 py-3 text-sm text-slate-300 hover:bg-slate-700 hover:text-white transition-colors flex items-center">
                            <i class="fas fa-file-export mr-2 w-5"></i> Eksportuj kopię
                        </button>
                    </div>
                </div>
            </div>

            <div class="relative">
                <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-400"></i>
                <input 
                    type="text" 
                    x-model="searchQuery" 
                    placeholder="Szukaj w tytułach..." 
                    class="w-full bg-slate-800 text-white rounded-full py-2 pl-10 pr-4 focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-slate-500 transition-all shadow-inner border border-slate-700"
                >
            </div>
        </div>
    </header>

    <!-- Główna Lista Notatek -->
    <main class="max-w-md mx-auto p-4 space-y-6">
        
        <template x-if="isLoading">
            <div class="text-center text-slate-500 mt-10">
                <i class="fas fa-spinner fa-spin fa-2x mb-2"></i>
                <p>Ładowanie wspomnień...</p>
            </div>
        </template>

        <template x-if="!isLoading && filteredNotes.length === 0">
            <div class="text-center text-slate-600 mt-20 flex flex-col items-center">
                <div class="bg-slate-800 p-6 rounded-full mb-4">
                    <i class="fas fa-feather-alt text-4xl text-slate-700"></i>
                </div>
                <p class="text-lg">Brak notatek</p>
                <p class="text-sm opacity-60">Naciśnij mikrofon, aby zacząć.</p>
            </div>
        </template>

        <template x-for="group in groupedNotes" :key="group.title">
            <div class="space-y-3">
                <h2 class="text-xs font-bold text-slate-500 uppercase tracking-wider pl-1" x-text="group.title"></h2>

                <template x-for="note in group.notes" :key="note.id">
                    <div class="bg-slate-800 rounded-xl p-5 shadow-lg relative group transition-all hover:bg-slate-750 border border-slate-700/50">
                        
                        <!-- Actions -->
                        <div class="absolute top-3 right-3 flex space-x-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <button @click="startEditing(note)" x-show="editingNoteId !== note.id" class="text-slate-500 hover:text-indigo-400 p-2"><i class="fas fa-pen"></i></button>
                            <button @click="deleteNote(note.id)" x-show="editingNoteId !== note.id" class="text-slate-500 hover:text-red-400 p-2"><i class="fas fa-times"></i></button>
                        </div>
                        
                        <!-- Tytuł (Auto-Generated) -->
                        <div class="mb-2">
                            <h3 class="text-lg font-bold text-white leading-tight" x-text="note.title || 'Bez tytułu'"></h3>
                        </div>

                        <!-- Data (pod tytułem, mniejsza) -->
                        <div class="text-xs text-indigo-400 font-medium mb-3 flex items-center">
                            <i class="far fa-clock mr-1"></i>
                            <span x-text="formatTime(note.date)"></span>
                        </div>
                        
                        <!-- Treść: Widok -->
                        <div x-show="editingNoteId !== note.id">
                            <p class="text-slate-300 text-sm leading-relaxed whitespace-pre-wrap opacity-80" x-text="note.text"></p>
                        </div>

                        <!-- Treść: Edycja -->
                        <div x-show="editingNoteId === note.id" class="mt-2">
                            <textarea x-model="editingText" class="w-full bg-slate-900/50 text-white rounded-lg p-3 border border-indigo-500/50 focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-y text-sm" rows="3"></textarea>
                            <div class="flex justify-end space-x-3 mt-3">
                                <button @click="cancelEditing()" class="text-sm text-slate-400 hover:text-white px-3 py-1">Anuluj</button>
                                <button @click="saveEdit(note.id)" class="text-sm bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-1.5 rounded-full shadow-lg flex items-center">
                                    <i class="fas fa-save mr-2"></i> Zapisz
                                </button>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </template>
        <div class="h-16"></div>
    </main>

    <!-- Podgląd nagrywania -->
    <div x-show="isRecording" style="display: none;"
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0 translate-y-10"
         x-transition:enter-end="opacity-100 translate-y-0"
         class="fixed bottom-24 left-0 right-0 px-4 z-40 pointer-events-none">
        <div class="max-w-md mx-auto bg-slate-800/90 backdrop-blur border border-indigo-500/30 p-4 rounded-2xl shadow-2xl text-center pointer-events-auto">
            <p class="text-indigo-300 text-sm mb-1 font-semibold animate-pulse flex justify-center items-center">
                <span class="recording-wave"></span>
                <span class="recording-wave"></span>
                <span class="recording-wave"></span>
                &nbsp;Nasłuchiwanie...
            </p>
            <p class="text-white text-lg italic" x-text="currentTranscript || 'Mów teraz...'"></p>
        </div>
    </div>

    <!-- FAB -->
    <div class="fixed bottom-6 left-0 right-0 flex justify-center z-50 pointer-events-none">
        <button 
            @click="toggleRecording()" 
            class="pointer-events-auto w-16 h-16 rounded-full shadow-2xl flex items-center justify-center text-2xl transition-all duration-300 transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-4 focus:ring-indigo-500/50"
            :class="isRecording ? 'bg-red-500 text-white animate-pulse-fast ring-4 ring-red-500/30' : 'bg-indigo-500 text-white hover:bg-indigo-600'"
            aria-label="Nagrywaj">
            <i class="fas" :class="isRecording ? 'fa-stop' : 'fa-microphone'"></i>
        </button>
    </div>

    <!-- Modal błędu -->
    <div x-show="errorMsg" style="display: none;" class="fixed inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4" x-transition.opacity>
        <div class="bg-slate-800 rounded-2xl p-6 max-w-sm w-full text-center border border-red-500/30 shadow-2xl">
            <div class="w-12 h-12 bg-red-500/10 rounded-full flex items-center justify-center mx-auto mb-4"><i class="fas fa-exclamation-triangle text-red-500 text-xl"></i></div>
            <h3 class="text-lg font-bold text-white mb-2">Wystąpił błąd</h3>
            <p class="text-slate-300 mb-6 text-sm" x-text="errorMsg"></p>
            <button @click="errorMsg = null" class="bg-slate-700 hover:bg-slate-600 text-white px-6 py-2 rounded-full w-full transition-colors">Rozumiem</button>
        </div>
    </div>

    <script>
        // --- KONFIGURACJA DŹWIĘKÓW (Base64) ---
        // Krótkie dźwięki generowane syntetycznie i zakodowane jako Base64, aby nie wymagały zewnętrznych plików
        const soundStartSrc = "data:audio/wav;base64,UklGRl9vT1BXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU"; // Bardzo krótki 'ping'
        // Rozszerzony Base64 dla lepszego dźwięku startu (używamy prostego audio object z API w init)
        // Tu generujemy dźwięki za pomocą AudioContext w kodzie, żeby oszczędzić miejsce i mieć lepszą jakość
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playBeep(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'start') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // A4
                oscillator.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1); // Slide up
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.1); // Slide down
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            }
        }

        // --- BAZA DANYCH ---
        const db = new Dexie('VoiceBrainDB');
        // UPGRADE DB: Dodajemy pole 'title' do wersji 2
        db.version(1).stores({ notes: '++id, date, text' });
        db.version(2).stores({ notes: '++id, date, text, title' });

        document.addEventListener('alpine:init', () => {
            Alpine.data('voiceJournal', () => ({
                notes: [],
                searchQuery: '',
                isRecording: false,
                manualStop: false, 
                currentTranscript: '',
                sessionTranscriptBuffer: '',
                currentSessionFinal: '',
                recognition: null,
                isLoading: true,
                errorMsg: null,
                
                // Edycja
                editingNoteId: null,
                editingText: '',
                
                // Wake Lock
                wakeLock: null,

                async init() {
                    console.log('Inicjalizacja Voice Brain v2...');
                    await this.loadNotes();
                    this.setupSpeechRecognition();
                },

                async loadNotes() {
                    try {
                        this.notes = (await db.notes.toArray()).sort((a, b) => b.date - a.date);
                    } catch (e) {
                        console.error('Błąd DB:', e);
                        this.errorMsg = 'Nie udało się załadować notatek.';
                    } finally {
                        this.isLoading = false;
                    }
                },

                get filteredNotes() {
                    if (!this.searchQuery) return this.notes;
                    const lowerQuery = this.searchQuery.toLowerCase();
                    // Szukamy w tytule i w treści
                    return this.notes.filter(note => 
                        (note.title && note.title.toLowerCase().includes(lowerQuery)) ||
                        (note.text && note.text.toLowerCase().includes(lowerQuery))
                    );
                },

                get groupedNotes() {
                    const groups = {};
                    const today = new Date().toDateString();
                    const yesterday = new Date(new Date().setDate(new Date().getDate() - 1)).toDateString();

                    this.filteredNotes.forEach(note => {
                        const noteDate = new Date(note.date).toDateString();
                        let groupTitle = noteDate;
                        if (noteDate === today) groupTitle = 'Dzisiaj';
                        else if (noteDate === yesterday) groupTitle = 'Wczoraj';
                        else groupTitle = new Date(note.date).toLocaleDateString('pl-PL', { weekday: 'long', day: 'numeric', month: 'long' });

                        if (!groups[groupTitle]) {
                            groups[groupTitle] = { title: groupTitle, notes: [] };
                        }
                        groups[groupTitle].notes.push(note);
                    });
                    return Object.values(groups); 
                },

                // --- GENERATOR TYTUŁÓW ---
                generateAutoTitle(text) {
                    if (!text || text.trim().length === 0) return 'Nowa notatka';
                    
                    // Usuń interpunkcję, weź pierwsze 4 słowa
                    const cleanText = text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"");
                    const words = cleanText.trim().split(/\s+/);
                    const titleWords = words.slice(0, 4);
                    
                    let title = titleWords.join(' ');
                    // Pierwsza litera wielka
                    title = title.charAt(0).toUpperCase() + title.slice(1);
                    
                    // Dodaj kropkę, jeśli tekst był dłuższy
                    if (words.length > 4) title += '...';
                    
                    return title;
                },

                async saveNote(text) {
                    if (!text || text.trim().length === 0) return;
                    try {
                        const title = this.generateAutoTitle(text);
                        await db.notes.add({
                            text: text.trim(),
                            title: title,
                            date: new Date()
                        });
                        await this.loadNotes();
                        if (navigator.vibrate) navigator.vibrate(50);
                    } catch (e) {
                        console.error('Błąd zapisu:', e);
                        this.errorMsg = 'Nie udało się zapisać notatki.';
                    }
                },

                async deleteNote(id) {
                    if (!confirm('Usunąć notatkę?')) return;
                    try {
                        await db.notes.delete(id);
                        await this.loadNotes();
                    } catch (e) {
                        console.error('Błąd usuwania:', e);
                        this.errorMsg = 'Nie udało się usunąć notatki.';
                    }
                },

                startEditing(note) {
                    this.editingNoteId = note.id;
                    this.editingText = note.text;
                },
                
                cancelEditing() {
                    this.editingNoteId = null;
                    this.editingText = '';
                },

                async saveEdit(id) {
                    try {
                        // Aktualizacja tekstu i tytułu (tytuł się zmieni po edycji!)
                        const title = this.generateAutoTitle(this.editingText);
                        await db.notes.update(id, { text: this.editingText, title: title });
                        await this.loadNotes();
                        this.editingNoteId = null;
                    } catch (e) {
                        this.errorMsg = 'Błąd aktualizacji notatki';
                    }
                },

                async exportBackup() {
                    try {
                        const allData = await db.notes.toArray();
                        const dataStr = JSON.stringify(allData, null, 2);
                        const blob = new Blob([dataStr], { type: "application/json" });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `voice-journal-backup-${new Date().toISOString().slice(0,10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        this.errorMsg = 'Nie udało się wyeksportować danych.';
                    }
                },

                // --- WAKE LOCK ---
                async requestWakeLock() {
                    if ('wakeLock' in navigator) {
                        try {
                            this.wakeLock = await navigator.wakeLock.request('screen');
                            console.log('Wake Lock aktywny');
                            this.wakeLock.addEventListener('release', () => {
                                console.log('Wake Lock zwolniony');
                                this.wakeLock = null;
                            });
                        } catch (err) {
                            console.error(`Błąd Wake Lock: ${err.name}, ${err.message}`);
                        }
                    }
                },

                releaseWakeLock() {
                    if (this.wakeLock !== null) {
                        this.wakeLock.release()
                            .then(() => { this.wakeLock = null; });
                    }
                },

                // --- WEB SPEECH API ---
                setupSpeechRecognition() {
                    this.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!this.SpeechRecognition) {
                        this.errorMsg = 'Twoja przeglądarka nie obsługuje rozpoznawania mowy.';
                    }
                },

                startRecordingLoop() {
                    if (!this.SpeechRecognition) return;

                    this.recognition = new this.SpeechRecognition();
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'pl-PL';

                    this.recognition.onstart = () => {
                        this.isRecording = true;
                        this.currentSessionFinal = ''; 
                        console.log('Nagrywanie rozpoczęte');
                        playBeep('start'); // Dźwięk startu
                    };

                    this.recognition.onresult = (event) => {
                        const results = event.results;
                        const lastResult = results[results.length - 1];
                        const transcript = lastResult[0].transcript;

                        if (lastResult.isFinal) {
                            this.currentSessionFinal = transcript;
                            this.currentTranscript = transcript;
                        } else {
                            this.currentTranscript = transcript;
                        }
                    };

                    this.recognition.onerror = (event) => {
                        console.error('Błąd Speech API:', event.error);
                        if (event.error === 'no-speech') return; 
                        if (event.error === 'network') {
                            // ignoruj, onend obsłuży restart
                        } else {
                             this.isRecording = false;
                             this.manualStop = true;
                        }
                    };

                    this.recognition.onend = () => {
                        console.log('Nagrywanie zakończone (event)');
                        
                        const newFinal = this.currentSessionFinal.trim();
                        const bufferEnd = this.sessionTranscriptBuffer.trim().slice(-newFinal.length);
                        
                        if (newFinal && newFinal !== bufferEnd) {
                            const cleanedNew = this.cleanText(newFinal);
                            if (cleanedNew) {
                                this.sessionTranscriptBuffer += (this.sessionTranscriptBuffer ? ' ' : '') + cleanedNew + ' ';
                            }
                        }
                        
                        this.currentSessionFinal = '';
                        this.currentTranscript = '';

                        if (!this.manualStop && this.isRecording) {
                            console.log('Auto-restart nagrywania...');
                            setTimeout(() => {
                                if(!this.manualStop) this.startRecordingLoop();
                            }, 100);
                        } else {
                            this.isRecording = false;
                            playBeep('stop'); // Dźwięk końca
                            this.releaseWakeLock(); // Zwolnij blokadę ekranu
                            
                            const finalToSave = this.sessionTranscriptBuffer.trim();
                            if (finalToSave) {
                                this.saveNote(finalToSave);
                            }
                            this.sessionTranscriptBuffer = '';
                        }
                    };

                    try {
                        this.recognition.start();
                    } catch (e) {
                        console.error('Start error:', e);
                    }
                },

                cleanText(text) {
                    if (!text) return '';
                    let clean = text.replace(/\s+/g, ' ').trim();
                    clean = clean.replace(/(\b\w{3,}\b)( \1\b)+/gi, '$1');
                    return clean;
                },

                toggleRecording() {
                    if (!this.SpeechRecognition) return;

                    if (this.isRecording) {
                        this.manualStop = true; 
                        if (this.recognition) this.recognition.stop();
                        this.isRecording = false;
                        // Dźwięk stopu i zwolnienie wake locka nastąpi w onend
                    } else {
                        this.manualStop = false;
                        this.sessionTranscriptBuffer = ''; 
                        this.currentSessionFinal = '';
                        this.currentTranscript = '';
                        this.requestWakeLock(); // Poproś o blokadę ekranu
                        this.startRecordingLoop();
                    }
                },

                formatTime(dateObj) {
                    if (!dateObj) return '';
                    return new Date(dateObj).toLocaleTimeString('pl-PL', { 
                        hour: '2-digit', minute: '2-digit' 
                    });
                }
            }));
        });
    </script>
</body>
</html>